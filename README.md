# Algorithm
It is based on Python language

### Data Structure (자료 구조)
> - 구현방법
>
> List : 각 데이터를 연이어 저장하는 기술
>
> Linked List : 각 데이터를 임의의 위치에 저장하고 서로 연결하는 기술
>
> - 자료구조 종류 : 배열, 스택, 큐, 트, 힙, 그래프, 데크 등
>
> - 배열 vs 리스트
>
> 배열 : 크기가 변하지 않음, 중간의 값을 지워도 빈칸으로 유지
>
> 리스트 : 크기가 변함, 중간의 값을 지우면 뒤의 것이 앞으로 이동
>
> - 데크
> 
> 리스트의 양쪽 끝에서 삽입과 삭제가 모두 이루어지는 자료구조
>
> 스택과 큐를 혼합한 구조로 하나의 배열을 선언한 후 2개의 포인터로 양쪽 끝을 가리키고 이것을 이용하여 양쪽에서 삽입, 삭제 연산을 수행
> 
> - 트리
> 
> 임의의 노드에서 다른 노드로의 경로가 하나밖에 없는 구조
> 
> 단 하나의 루트 노드에서 하위 노드들이 연결된 비선형 자료구조 
> 
> 이진트리 : 모든 노드가 최대 2개의 자식 노드를 가질 수 있는 구조. 루트보다 작으면 왼쪽, 루트보다 크면 오른쪽으로 둠
>
> 주로 빠른 검색이 필요할 때 이진트리검색 사용
>
> - 힙
>
> 이진 트리의 일종, 여러 개의 값 중에서 가장 큰 값이나 가장 작은 값을 빠르게 찾을 수 있도록 구성된 자료구조
>
> 우선순위가 부여된 프로세스를 최대 힙으로 구성하면, 우선순위 숫자가 큰 프로세스가 최상위에 위치함 -> 프로세스 요청 시 최상위 노드에 있는 프로세스 반환->
> 루트 노드가 반환되면 나머지 노드를 우선순위 숫자에 근거하여 트리 구조를 재구성, 가장 높은 우선순위를 가지는 프로세스가 루트 노드에 위치하게 됨 
> 
> 최소 힙 : 부모 노드의 값이 항상 하위 노드의 값보다 작은 경우
> 
> 최대 힙 : 부모 노드의 값이 항상 하위 노드의 값보다 큰 경우, 가장 큰 값이 최상위 노드에 위치, 두 수 비교하여 큰 값을 위로 올리며 자리바꾸네.
>
> - 그래프
> 
> 2개 이상의 항목이 어떤 관계를 맺고 있는지 노드와 엣지를 이용하여 표현하는 것 / 
> 방향이 있는 그래프, 방향이 없는 그래프
>
> 페이스북이나 트위터에서 각 사용자가 다른 사용자와 어떤 관계를 맺는지 표현하는 경우 그래프를 사용함
> 
> 깊이 우선 탐색
>
> 너비 우선 탐색
> 
> 신장 트리 : 그래프 안의 모든 정점을 포함하는 트리, 모든 정점들이 연결되어 있어야 하고 사이클을 포함하지 않음
> 
> 최소 비용 신장 트리 : 가중치가 부여된 무방향 그래프에서 신장 트리 비용의 최소화를 구하는 방법
>
> PERT/CPM : 비용을 적게 사용하면서 최단 시간 안에 계획을 완성하기 위한 프로젝트 일정 관리 기법
> 
> 최단 경로 : 그래프에서 정점 a, b를 연결하는 경로 중에 가중치의 합이 최소가 되는 경로를 찾는 방법
> 
> - 자바 컬렉션에서 제공하는 자료구조
> 
> 인터페이스 : SET<E>, LIST<E>, QUEUE<E>, MAP<K,V> / 클래스 : HashSet<E>, ArrayList<E>, Vector<E>, Stack<E>, LinkedList<E>, HashMap<K,V>
>
> HashSet : 값만 저장할 때 주로 사용, 중복 X, 키나 인덱스 저장에 주로 사용
>
> HashMap : 키와 값이 쌍으로 이루어진 데이터를 다룸
>
>
> ### Sort Algorithm (정렬 알고리즘)
> 
> - 버킷 정렬 알고리즘 : 자료를 버킷이라는 단위 기억 장소에 정렬하고, 버킷별 키 값에 따라 다시 정렬하는 알고리즘
>
> - 기수 정렬 알고리즘 : 데이터의 모양에 따른 제한이 있는 버킷 정렬을 개선하여 만든 것. 각 자릿수별로 버킷 정렬을 반복 수행하는 방법
>
> - 선택 정렬 알고리즘 : 가장 작은 데이터를 찾아 가장 앞 데이터와 교환 -> 그 다음으로 작은 데이터를 찾아 두 번째와 위치를 교환. ... 이 과정을 반복하여 정렬
> 
> - 교환 정렬 알고리즘 : 작은 것부터 큰 순서로 정렬할 경우, 작은 키를 갖는 데이터를 찾아 앞 데이터와 교환하는 방법. 앞에서부터 인접한 두개의 크기를 비교하여 작은 것이 앞으로 가도록 교환, 반복...
>
> - 삽입 정렬 알고리즘 : 교환과 비슷하나 위치 교환이 발생한 것을 대상으로 주변의 것과 비교하여 위치를 교환하는 방법
>
> - 쉘 정렬 알고리즘 : 느린 속도의 삽입 정렬을 보완하여 만든 것. 데이터의 그룹을 나누어 그룹 안에서 쉘 정렬을 수행하고 마지막에 삽입 정렬을 수행하는 방법
>  
> - 병합 정렬 알고리즘 : 데이터를 분할한 다음 각자 계산하고 나중에 합쳐서 정렬하는 방법. 정렬할 데이터를 최소 단위(1개)가 될 때까지 분할 작업 반복 -> 
  분할된 데이터를 대상으로 2개, 4개, 8개씩 병합하면서 정렬 수행 -> 최종적으로 2개의 무리가 만들어진 후 2차 병합 정렬 알고리즘을 적용
>
> - 퀵 정렬 알고리즘 : 중앙값 정렬 방식. 임의로 선정된 데이터를 중심으로 데이터를 2등분 -> 각 분리된 부분의 첫번째 원소를 기준으로 데이터를 분리 -> 반복
>
> - 힙 정렬 알고리즘 : 주어진 자료로 힙 구성. 최상위 데이터를 가장 큰 수로 설정. 최상위 데이터를 빼고 나면 나머지 데이터로 다시 힙을 구성. 가장 큰 수를 최상위 데이터로. 반복 -> 큰 수에서 작은 수로 정렬됨
>
> 
> ### Search Algorithm (검색 알고리즘)
> 
> - 순차 검색 알고리즘 : 주어진 데이터를 처음부터 검색하는 방법. 
>
> - 이진 검색 알고리즘 : 정렬된 데이터를 대상으로 중앙 값을 이용하여 검색하는 방법. 전체 데이터의 중앙값 선택 -> 중앙값과 찾고자 하는 값 비교 -> 중앙값이 더 크면 왼쪽 부분의 중앙값을 취하고 다시 찾고자 하는 값과 비교. 중앙값이 더 작으면 오른쪽 부분의 중앙값을 취하고 다시 찾고자 하는 값과 비교 -> 중앙값과 찾고자 하는 값이 같을 때 종료
>
> - 문자열 검색 알고리즘 :  주어진 문자열에서 찾고자 하는 문자열의 위치를 찾는 알고리즘
>
> - KMP 검색 알고리즘 : 문자열 안에서 부분 문자열을 검색할 때, 검색에 실패한 위치를 기반으로 비교할 필요가 없는 문자열은 건너뛰고, 다음 번 검색 위치를 결정하는 알고리즘
> 
> - BM 검색 알고리즘 : 문자열을 데이터에서 검색할 때, 검색할 문자열의 끝에서부터 비교하다가 일치하지 않는 문자를 만나면 검색할 문자열만큼 이동하여 검색을 수행하는 알고리즘
>
